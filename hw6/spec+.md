### Exercise 1 "Rozetta"

- 뼈대코드 : http://ropas.snu.ac.kr/~ta/4190.310/15/document/Rozetta_skel.zip
- 뼈대코드에는 SM5와 Sonata의 실행기가 제공되어 있습니다.
뼈대코드 디렉토리에서 make 명령을 실행하시면 숙제 전체가 컴파일되고, 'run' 이라는 실행파일이 생성됩니다.
run 파일을 다음과 같이 실행하시면 입력으로 받은 SM5프로그램을 Sonata 프로그램으로 번역하여, Sonata 실행기로 실행합니다.
- 코드:
> $ make
>
> $ ./run examples/test1.sm5

- 그 외에 다양한 옵션 (번역된 Sonata 프로그램 출력하기, 번역하지 않고 SM5 기계로 실행하기, 디버그 모드로 실행하기 등)을 지원합니다. README 파일을 참고하시기 바랍니다.
- 뼈대코드 중 rozetta.ml 파일을 제출합니다. 꼭 주의해 주세요, 엉뚱한 ml 파일을 잘못 제출하시면 조교팀이 해결해 드릴 방법이 없습니다.
- TODO로 표시되어 있는 Rozetta.trans 함수를 구현해서 제출하시면 됩니다.
- 번역 과정에서, SM5 프로그램에서 사용하는 변수 이름과 겹치지 않는 변수 이름이 필요한 경우가 있습니다.
- 여러분의 편의를 위해 SM5 언어에서 사용하는 변수 이름에는 #, @와 같은 특수문자를 사용되지 않는다고 가정하겠습니다.
- 입력으로 들어온 Sm5 프로그램은 loc 상수나 record 상수를 push하지 않는다고 가정하겠습니다. 이런 명령은 입력으로 들어오지 않으므로 자유롭게 예외 처리해 주시기 바랍니다.
이런 프로그램을 제외하는 이유는, 사용할 주소가 하드코딩되어 있는 특이한 코드이기 때문입니다. C 언어에 비유하자면 다음과 같은 코드에 해당합니다.
프로그램이 돌고 있는 운영체제 및 기계를 확실히 꿰고있을 때에만 매우 제한적으로 쓰일 수 있는 코드입니다.

- 코드:
> int *p = (int *)0x08048576;
>
> int x = *p;
>
> ...

loc 상수나 record 상수를 push하는 코드를 번역하는 것은, SM5/Sonata의 malloc()의 동작과 맞물려 너무 복잡해지기 때문에 번역의 대상에서 제외합니다.

- (11/16 밤) 뼈대코드에 업데이트가 있었습니다. 우선, 뼈대코드에 조금 더 많은 코드를 드리고 핵심적인 부분만 여러분이 빈칸을 채워넣도록 하였습니다. 또한 불필요한 모듈 선언을 제거하였습니다. 이제 Rozetta 파일 안에서 "open Sm5.Sm5" 처럼 이름공간을 두 번 쓸 필요가 없습니다. 새로 배포한 뼈대코드에서 문제없이 컴파일 되는지 확인해 주고 제출해 주시기 바랍니다. 일찍 숙제를 시작한 분들에게 불편을 드려 죄송합니다.

### Exercise 2 "앞으로 할 일 드러내기"

- 뼈대코드 : http://ropas.snu.ac.kr/~ta/4190.310/15/document/CPS_skel.zip
- 뼈대코드에는 mexp (M0로 칭하겠습니다) 언어의 파서와 실행기 일부가 제공되어 있습니다.
뼈대코드 디렉토리에서 make 명령을 실행하시면 숙제 전체가 컴파일되고, 'run' 이라는 실행파일이 생성됩니다.
run 파일을 다음과 같이 실행하시면 입력으로 받은 M0 프로그램을 실행하고, CPS로 번역한 다음 실행합니다. 이 때 두 실행 결과는 같아야 합니다.
- 코드:
> $ make
>
> $ ./run examples/test1.m

- 뼈대코드 중 cps.ml 파일을 제출합니다. 꼭 주의해 주세요, 엉뚱한 ml 파일을 잘못 제출하시면 조교팀이 해결해 드릴 방법이 없습니다.
- TODO로 표시한 CPS.cps 함수를 구현하셔서 제출하면 됩니다.
- (11/16) 예고해 드린대로 뼈대코드가 업데이트되었습니다. 기존의 계획과 달리 , 뼈대코드에 조금 더 많은 코드를 드리고 여러분이 빈칸을 채워넣도록 하는 것으로 변경되었습니다. 각 케이스에 대해 "todo"로 표시해 둔 부분을 알맞게 채워넣으시기 바랍니다.
- (11/16 밤) 뼈대코드에 다시 한 번 업데이트가 있었습니다. 뼈대코드에서 제공해드리는 코드를 줄였으며, 불필요한 모듈 선언 등을 제거하였습니다. 새로 배포한 뼈대코드에서 문제없이 컴파일 되는지 확인해 주고 제출해 주시기 바랍니다. 일찍 숙제를 시작한 분들에게 불편을 드려 죄송합니다.
- (11/19 추가) 올바른 CPS 변환에 대한 조건들을 제공합니다. 작성하신 코드는 다음 조건을 만족해야 합니다.

  > 1. 우선, 실행 결과는 당연히 변환 전과 후가 같아야 합니다.
  > 2. 어떤 mexp에 나타난 sub-expression들은 모두 cps 변환되어야 합니다. 예를 들어 cps(e1+e2)의 경우, e1, e2는 각각 cps로 변환된 (cps e1), (cps e2) 형태로 나타나야 합니다.
  > 3. e가 상수(Num, Fun, Fn, Rec) 일때만 cps(e) = \k.k(...) 형태를 허용합니다. 상수의 경우 계산할 게 없으므로 바로 k에 전달하는 것입니다.
  > 4. e가 상수가 아니면 항상 cps(e) = \k....(\v....k... ) 형태로 변형되어야 합니다. 복합식의 경우, 일부를 먼저 변환하고 남은 할 일을 k를 가지고 구성해서 전달하는 것입니다.

  예시를 들어드린 Add의 경우를 보면, 복합식 e1 + e2 에서 일부인 e1을 변환한 다음, 앞으로 할 일을 인자로 전해주고 있습니다. 이 '앞으로 할 일'을 정의하는 데 k가 사용되고요.

  인용:
  > cps(e1 + e2) = \k. (cps e1) (\v1. (cps e2) (\v2. k (v1 + v2) ) )

### Exercise 3. "M Interpreter"
- 뼈대코드 : http://ropas.snu.ac.kr/~ta/4190.310/15/document/M_skel.zip
- 뼈대코드에는 M 언어의 파서와 실행기 일부가 제공되어 있습니다.
- 뼈대코드 디렉토리에서 make 명령을 실행하시면 숙제 전체가 컴파일되고, 'run' 이라는 실행파일이 생성됩니다.
- run 파일을 다음과 같이 실행하시면 입력으로 받은 M 프로그램을 실행합니다.
- 코드:
> $ make
>
> $ ./run examples/test1.m

- 뼈대코드 중 m.ml 파일을 제출합니다. 꼭 주의해 주세요, 엉뚱한 ml 파일을 잘못 제출하시면 조교팀이 해결해 드릴 방법이 없습니다. 특히, 과제 6-2의 m0.ml을 제출하지 않도록 주의하세요.
- M.run 함수에 TODO로 표시한 빈 부분들을 완성하셔서 제출하면 됩니다.

- 언어의 스펙은 http://ropas.snu.ac.kr/~kwang/4190.310/14/M.pdf 를 따라갑니다.

1. 알맞은 타입이 오지 않을 경우 (예 : 정수에 스트링을 더한기) TypeError 예외를 발생시킵니다. 예외 인자는 자유롭게 정하면 됩니다.
2. EQUAL Semantics에 대해 : 3장 "Static Semantics: Type System"의 스펙을 따라 다음과 같이 정합니다.

    > 서로 다른 타입을 비교하거나, Pair끼리의 비교, Closure끼리의 비교는 타입 에러입니다.
